type Query {
  node(id: ID!): Node
  # User related top-level queries
  user(where: UserWhereUniqueInput!): User
  users(
    where: UserWhereInput
    orderBy: UserOrderByInput
    skip: Int
    after: ID
    before: ID
    first: Int
    last: Int
  ): [User!]!
  usersConnection(
    where: UserWhereInput
    orderBy:UserOrderByInput
    skip: Int
    after: ID
    before: ID
    first: Int
    last: Int): UserConnection!
  # Profile related top-level queries
  profile(where: ProfileWhereUniqueInput!): Profile
  profiles(
    where: ProfileWhereInput
    orderBy: ProfileWhereInput
    skip: Int
    after: ID
    before: ID
    first: Int
    last: Int
  ): [Profile!]!
  profilesConnection(
    where: ProfileWhereInput
    orderBy: ProfileWhereInput
    skip: Int
    after: ID
    before: ID
    first: Int
    last: Int
  ): ProfileConnection!
  # Post related top-level queries
  post(where: PostWhereUniqueInput!): Post
  posts(
    where: PostWhereInput,
    orderBy: PostOrderByInput,
    skip: Int
    after: ID
    before: ID
    first: Int
    last: Int
  ): [Post!]!
  postsConnection(
    where: PostWhereInput,
    orderBy: PostOrderByInput,
    skip: Int
    after: ID
    before: ID
    first: Int
    last: Int
  ): [Post!]!
  # Category related top-level queries
  category(where: CategoryWhereUniqueInput!): Category
  categories(
    where: CategoryWhereInput
    orderBy: CategoryOrderByInput
    skip: Int
    after: ID
    before: ID
    first: Int
    last: Int
  ): [Category!]!
  categoriesConnection(
    where: CategoryWhereInput
    orderBy: CategoryOrderByInput
    skip: Int
    after: ID
    before: ID
    first: Int
    last: Int
  ): CategoryConnection!
}

type Mutation {
  # User
  createUser(data: UserCreateInput!): User
  updateUser(
    where: UserWhereUniqueInput!
    data: UserUpdateInput!
  ): User
  deleteUser(where: UserWhereUniqueInput!): User
  updateManyUsersConnection(
    where: UserWhereInput! 
    data: UserUpdateManyInput!
    skip: Int
    after: ID
    before: ID
    first: Int
    last: Int
  ): UserConnection!
  deleteManyUsersConnection(
    where: UserWhereInput!
    skip: Int
    after: ID
    before: ID
    first: Int
    last: Int
    ): UserConnection!
  # Profile
  createProfile(data: ProfileCreateInput!): Profile
  updateProfile(
    where: ProfileWhereUniqueInput! 
    data: ProfileUpdateInput!
    ): Profile
  deleteProfile(where: ProfileWhereUniqueInput!): Profile
  updateManyProfilesConnection(
    where: ProfileWhereInput!
    data: ProfileUpdateManyInput!
    skip: Int
    after: ID
    before: ID
    first: Int
    last: Int
  ): ProfileConnection!
  deleteManyProfilesConnection(
    where: ProfileWhereInput!
    skip: Int
    after: ID
    before: ID
    first: Int
    last: Int
  ): ProfileConnection!
  # Post
  createPost(data: PostCreateInput!): Post
  updatePost(
    where: PostWhereUniqueInput! 
    data: PostUpdateInput!
    ): Post
  deletePost(where: PostWhereUniqueInput!): Post
  updateManyPostsConnection(
    where: PostWhereInput!
    data: PostUpdateManyInput!
    skip: Int
    after: ID
    before: ID
    first: Int
    last: Int
  ): PostConnection!
  deleteManyPostsConnection(
    where: PostWhereInput!
    skip: Int
    after: ID
    before: ID
    first: Int
    last: Int
  ): PostConnection!
  # Category
  createCategory(data: CategoryCreateInput!): Category
  updateCategory(
    where: CategoryWhereUniqueInput! 
    data: CategoryUpdateInput!
    ): Category
  deleteCategory(where: CategoryWhereUniqueInput!): Category
  updateManyCategoriesConnection(
    where: CategoryWhereInput!
    data: CategoryUpdateManyInput!
    skip: Int
    after: ID
    before: ID
    first: Int
    last: Int
  ): CategoryConnection!
  deleteManyCategoriesConnection(
    where: CategoryWhereInput!
    skip: Int
    after: ID
    before: ID
    first: Int
    last: Int
  ): CategoryConnection!
}

type Node {
  id: ID!
}
type User implements Node {
  id: ID! @unique
  email: String! @unique
  name: String
  nickNames: [String!]! # Let (non-connection / non-relation) array fields generated be always non-null for both array and elements.
  role: Role!
  profile: Profile
  posts(
    where: PostWhereInput
    orderBy: PostOrderByInput
    skip: Int
    after: ID
    before: ID
    first: Int
    last: Int
  ):[Post!]!
  postsConnection(
    where: PostWhereInput
    orderBy: PostOrderByInput
    skip: Int
    after: ID
    before: ID
    first: Int
    last: Int
  ): PostConnection!
}

type Profile implements Node {
  id: ID! @unique
  bio: String
  user: User!
}

type Post implements Node {
  id: ID! @unique
  createdAt: DateTime!
  updatedAt: DateTime!
  title: String!
  published: Boolean
  author: User!
  categories(
    where: CategoryWhereInput
    orderBy: CategoryOrderByInput
    skip: Int
    after: ID
    before: ID
    first: Int
    last: Int
  ): [Category!]!
  categoriesConnection(
    where: CategoryWhereInput
    orderBy: CategoryOrderByInput
    skip: Int
    after: ID
    before: ID
    first: Int
    last: Int
  ): CategoryConnection!
}

type Category implements Node{
  id: ID! @unique
  name: String! @unique
  posts(
    where: PostWhereInput
    orderBy: PostOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ):[Post!]!
  postsConnection(
    where: PostWhereInput
    orderBy: PostOrderByInput
    skip: Int
    after: ID
    before: ID
    first: Int
    last: Int
  ): PostConnection!
}

enum Role {
  USER
  ADMIN
}

input UserCreateInput {
  email: String!
  name: String
  nickNames: [String!]! 
  role: Role!
  profile: ProfileCreateOneInlineInput
  posts: PostCreateManyInlineInput
}

input UserCreateManyInlineInput {
  create: [UserCreateInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateOneInlineInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserUpdateManyInput {
  email: String!
  name: String
  nickNames: [String!]!
  role: Role!
}

input UserUpdateInput {
  email: String! 
  name: String
  nickNames: [String!]! # Let (non-connection / non-relation) array fields generated be always non-null for both array and elements.
  role: Role!
  profile: ProfileUpdateOneInlineInput
  posts: PostUpdateManyInlineInput
}

input UserUpsertInput {
  create: UserCreateInput!
  update: UserUpdateInput!
}

input UserUpdateManyInlineInput {
  # Create and connect mutliple users
  create: [UserCreateInput!]
  # Connect multiple existing users
  connect: [UserConnectInput!]
  # Override currently-connected users with multiple existing users
  set: [UserWhereUniqueInput!]
  # Update multiple users
  update: [UserUpdateWithNestedWhereUniqueInput!]
  # Upsert multiple user
  upsert: [UserUpsertWithNestedWhereUniqueInput!]
  # Disconnect multiple users
  disconnect: [UserWhereUniqueInput!]
  # Delete multiple users
  delete: [UserWhereUniqueInput!]
}

input UserUpdateOneInlineInput {
  create: UserCreateInput
  update: UserUpdateWithNestedWhereUniqueInput
  upsert: UserUpsertWithNestedWhereUniqueInput
  connect: UserWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
}

input UserUpdateWithNestedWhereUniqueInput {
  where: UserWhereUniqueInput!
  data: UserUpdateInput!
}

input UserUpsertWithNestedWhereUniqueInput {
  where: UserWhereUniqueInput!
  data: UserUpsertInput!
}

input UserConnectInput {
  # User to connect
  where: UserWhereUniqueInput!
  # specify the position in the list of connected users, by-defult will add it to end of the list
  position: ConnectPositionInput
}

input ConnectPositionInput {
  # Connect after the speficied ID
  after: ID
  # Connect before the specified ID
  before: ID
  # Connect at the first position
  start: Boolean
  # Connect at the last position. [default]
  end:Boolean
}

input ProfileCreateInput {
  bio: String
  user: UserCreateOneInlineInput!
}

input ProfileCreateManyInlineInput {
  create: [ProfileCreateInput!]
  connect: [ProfileWhereUniqueInput!]
}

input ProfileCreateOneInlineInput {
  create: ProfileCreateInput
  connect: ProfileWhereUniqueInput
}

input PostCreateInput {
  createdAt: DateTime!
  updatedAt: DateTime!
  title: String!
  published: Boolean
  author: UserCreateOneInlineInput!
  categories: CategoryCreateManyInlineInput
}

input PostCreateManyInlineInput {
  create: [PostCreateInput!]
  connect: [PostWhereUniqueInput!]
}

input PostCreateOneInlineInput {
  create: PostCreateInput
  connect: PostWhereUniqueInput
}

input CategoryCreateInput {
  name: String!
  posts: PostCreateManyInlineInput
}

input CategoryCreateManyInlineInput {
  create: [CategoryCreateInput!]
  connect: [CategoryWhereUniqueInput!]
}

input CategoryCreateOneInlineInput {
  create: CategoryCreateInput
  connect: CategoryWhereUniqueInput
}

input UserWhereInput {
  # Logical AND on all given filters
  AND: [UserWhereInput!]
  # Logical OR on all given filters
  OR: [UserWhereInput!]
  # Logical NOT on all given filters combined by AND.
  NOT: [UserWhereInput!]

  id: String # equals
  id_not: String # not equals
  id_contains: String # contains substring
  id_not_contains: String # doesn't contain substring
  id_starts_with: String
  id_not_starts_with: String
  id_ends_with: String
  id_not_ends_with: String
  id_lt: String # less than
  id_lte: String # less than or equal
  id_gt: String # greater than
  id_gte: String # greater than or equal
  id_in: [String] # in list
  id_not_in: [String] # not in list

  email: String # equals
  email_not: String # not equals
  email_contains: String # contains substring
  email_not_contains: String # doesn't contain substring
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  email_lt: String # less than
  email_lte: String # less than or equal
  email_gt: String # greater than
  email_gte: String # greater than or equal
  email_in: [String] # in list
  email_not_in: [String] # not in list

  name: String # equals
  name_not: String # not equals
  name_contains: String # contains substring
  name_not_contains: String # doesn't contain substring
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  name_lt: String # less than
  name_lte: String # less than or equal
  name_gt: String # greater than
  name_gte: String # greater than or equal
  name_in: [String] # in list
  name_not_in: [String] # not in list

  nickNames_contains: String # contains single scalar T
  nickNames_contains_every: [String] # contains all scalar T
  nickNames_contains_some: [String] # contains atleast one scalar T

  role: Role # equals
  role_not: Role # not equals
  role_in: [Role] # in list
  role_not_in: [Role] # not in list

  profile: ProfileWhereInput # condition must be true for related node.

  posts_every: PostWhereInput # condition must be true for all nodes.
  posts_some: PostWhereInput # condition must be true for atleast 1 node
  posts_none: PostWhereInput # condition must be false for all nodes
  posts_is_null: PostWhereInput # is the relation field null or empty ?
}

input UserWhereUniqueInput {
  id: ID
  email: String
}

enum UserOrderByInput {
  id_ASC,
  id_DSC,
  email_ASC,
  email_DSC,
  nickNames_ASC, # ToDo:: Find out if they are ordered by list count.
  nickNames_DSC, 
  role_ASC, # ToDo:: Find out if they are ordered by location of enum, or enum name ?
  role_DSC,
}

input UserConnection {

}

"""A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the date-timeformat outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representationof dates and times using the Gregorian calendar."""
scalar DateTime

"""This object field maps to a different field name in SDML model."""
directive @map(
"""SDML model field name"""
name: String!
) on
| FIELD_DEFINITION

"""When applied to an object field, the value of the field should be unique across all object instances of the same type"""
directive @unique on
| FIELD_DEFINITION

"""Node interface as per Relay GraphQL Global Object Identification Spec. https://relay.dev/docs/guides/graphql-server-specification/#object-identification"""
interface Node {
"""ID field with globally unique ID"""
id: ID! @unique
}

enum Role {
USER
ADMIN
}

type PageInfo {
"""When paginating forwards, are there more items ?"""
hasNextPage: Boolean!
"""When paginating backwards, are there more items ?"""
hasPreviousPage: Boolean!
"""When paginating backwards, cursor to continue."""
startCursor: String
"""When paginating forwards, cursor to continue."""
endCursor: String
"""Number of items in current page."""
pageSize: Int
}

type Aggregate {
count: Int!
}

"""The where filter which can match zero or more objects"""
input UserWhereInput {
"""Logical AND on all given filters."""
AND: [UserWhereInput!]
"""Logical OR on all given filters."""
OR: [UserWhereInput!]
"""Logical NOT on all given filters combined by AND."""
NOT: [UserWhereInput!]
"""equals"""
id: String
"""not equals"""
id_not: String
"""contains substring"""
id_contains: String
"""doesn't contain substring"""
id_not_contains: String
id_starts_with: String
id_not_starts_with: String
id_ends_with: String
id_not_ends_with: String
"""less than"""
id_lt: String
"""less than or equals"""
id_lte: String
"""greater than"""
id_gt: String
"""greater than or equals"""
id_gte: String
"""in list"""
id_in: [String]
"""not in list"""
id_not_in: [String]
"""equals"""
email: String
"""not equals"""
email_not: String
"""contains substring"""
email_contains: String
"""doesn't contain substring"""
email_not_contains: String
email_starts_with: String
email_not_starts_with: String
email_ends_with: String
email_not_ends_with: String
"""less than"""
email_lt: String
"""less than or equals"""
email_lte: String
"""greater than"""
email_gt: String
"""greater than or equals"""
email_gte: String
"""in list"""
email_in: [String]
"""not in list"""
email_not_in: [String]
"""equals"""
name: String
"""not equals"""
name_not: String
"""contains substring"""
name_contains: String
"""doesn't contain substring"""
name_not_contains: String
name_starts_with: String
name_not_starts_with: String
name_ends_with: String
name_not_ends_with: String
"""less than"""
name_lt: String
"""less than or equals"""
name_lte: String
"""greater than"""
name_gt: String
"""greater than or equals"""
name_gte: String
"""in list"""
name_in: [String]
"""not in list"""
name_not_in: [String]
"""equals"""
nickNames: String
"""not equals"""
nickNames_not: String
"""contains substring"""
nickNames_contains: String
"""doesn't contain substring"""
nickNames_not_contains: String
nickNames_starts_with: String
nickNames_not_starts_with: String
nickNames_ends_with: String
nickNames_not_ends_with: String
"""less than"""
nickNames_lt: String
"""less than or equals"""
nickNames_lte: String
"""greater than"""
nickNames_gt: String
"""greater than or equals"""
nickNames_gte: String
"""in list"""
nickNames_in: [String]
"""not in list"""
nickNames_not_in: [String]
"""equals"""
role: Role
"""not equals"""
role_not: Role
"""in list"""
role_in: [Role]
"""not in list"""
role_not_in: [Role]
"""condition must be true for all nodes"""
mentees_every: UserWhereInput
"""condition must be true for at least 1 node"""
mentees_some: UserWhereInput
"""condition must be false for all nodes"""
mentees_none: UserWhereInput
"""is the relation field empty"""
mentees_is_empty: Boolean
"""condition must be true for related node"""
mentor: UserWhereInput
"""is the relation field null"""
mentor_is_null: Boolean
"""equals"""
mentorEmail: String
"""not equals"""
mentorEmail_not: String
"""contains substring"""
mentorEmail_contains: String
"""doesn't contain substring"""
mentorEmail_not_contains: String
mentorEmail_starts_with: String
mentorEmail_not_starts_with: String
mentorEmail_ends_with: String
mentorEmail_not_ends_with: String
"""less than"""
mentorEmail_lt: String
"""less than or equals"""
mentorEmail_lte: String
"""greater than"""
mentorEmail_gt: String
"""greater than or equals"""
mentorEmail_gte: String
"""in list"""
mentorEmail_in: [String]
"""not in list"""
mentorEmail_not_in: [String]
"""condition must be true for related node"""
spouse: UserWhereInput
"""is the relation field null"""
spouse_is_null: Boolean
"""equals"""
spouseUserId: String
"""not equals"""
spouseUserId_not: String
"""contains substring"""
spouseUserId_contains: String
"""doesn't contain substring"""
spouseUserId_not_contains: String
spouseUserId_starts_with: String
spouseUserId_not_starts_with: String
spouseUserId_ends_with: String
spouseUserId_not_ends_with: String
"""less than"""
spouseUserId_lt: String
"""less than or equals"""
spouseUserId_lte: String
"""greater than"""
spouseUserId_gt: String
"""greater than or equals"""
spouseUserId_gte: String
"""in list"""
spouseUserId_in: [String]
"""not in list"""
spouseUserId_not_in: [String]
"""condition must be true for related node"""
profile: ProfileWhereInput
"""is the relation field null"""
profile_is_null: Boolean
"""condition must be true for all nodes"""
posts_every: PostWhereInput
"""condition must be true for at least 1 node"""
posts_some: PostWhereInput
"""condition must be false for all nodes"""
posts_none: PostWhereInput
"""is the relation field empty"""
posts_is_empty: Boolean
}

"""The where unique filter which can match at-most 1 object."""
input UserWhereUniqueInput {
id: ID
email: String
spouseUserId: String
}

"""Order by input for User's scalar fields"""
enum UserOrderByInput {
id_ASC
id_DSC
email_ASC
email_DSC
name_ASC
name_DSC
role_ASC
role_DSC
mentorEmail_ASC
mentorEmail_DSC
spouseUserId_ASC
spouseUserId_DSC
}

"""User"""
type User implements Node {
id: ID! @map(name: "userId") @unique
email: String! @unique
name: String
nickNames: [String!]!
role: Role!
mentees(
where: UserWhereInput
orderBy: UserOrderByInput
skip: Int
after: ID
before: ID
first: Int
last: Int
): [User!]!
menteesConnection(
where: UserWhereInput
orderBy: UserOrderByInput
skip: Int
after: ID
before: ID
first: Int
last: Int
): [UserConnection!]!
mentor: User
mentorEmail: String
spouse: User
spouseUserId: String @unique
profile: Profile
posts(
where: PostWhereInput
orderBy: PostOrderByInput
skip: Int
after: ID
before: ID
first: Int
last: Int
): [Post!]!
postsConnection(
where: PostWhereInput
orderBy: PostOrderByInput
skip: Int
after: ID
before: ID
first: Int
last: Int
): [PostConnection!]!
}

type UserEdge {
node: User!
cursor: String!
}

type UserConnection {
pageInfo: PageInfo!
edges: [UserEdge!]!
aggregate: Aggregate!
}

"""The where filter which can match zero or more objects"""
input ProfileWhereInput {
"""Logical AND on all given filters."""
AND: [ProfileWhereInput!]
"""Logical OR on all given filters."""
OR: [ProfileWhereInput!]
"""Logical NOT on all given filters combined by AND."""
NOT: [ProfileWhereInput!]
"""equals"""
id: String
"""not equals"""
id_not: String
"""contains substring"""
id_contains: String
"""doesn't contain substring"""
id_not_contains: String
id_starts_with: String
id_not_starts_with: String
id_ends_with: String
id_not_ends_with: String
"""less than"""
id_lt: String
"""less than or equals"""
id_lte: String
"""greater than"""
id_gt: String
"""greater than or equals"""
id_gte: String
"""in list"""
id_in: [String]
"""not in list"""
id_not_in: [String]
"""equals"""
bio: String
"""not equals"""
bio_not: String
"""contains substring"""
bio_contains: String
"""doesn't contain substring"""
bio_not_contains: String
bio_starts_with: String
bio_not_starts_with: String
bio_ends_with: String
bio_not_ends_with: String
"""less than"""
bio_lt: String
"""less than or equals"""
bio_lte: String
"""greater than"""
bio_gt: String
"""greater than or equals"""
bio_gte: String
"""in list"""
bio_in: [String]
"""not in list"""
bio_not_in: [String]
"""condition must be true for related node"""
user: UserWhereInput
"""is the relation field null"""
user_is_null: Boolean
"""equals"""
userEmail: String
"""not equals"""
userEmail_not: String
"""contains substring"""
userEmail_contains: String
"""doesn't contain substring"""
userEmail_not_contains: String
userEmail_starts_with: String
userEmail_not_starts_with: String
userEmail_ends_with: String
userEmail_not_ends_with: String
"""less than"""
userEmail_lt: String
"""less than or equals"""
userEmail_lte: String
"""greater than"""
userEmail_gt: String
"""greater than or equals"""
userEmail_gte: String
"""in list"""
userEmail_in: [String]
"""not in list"""
userEmail_not_in: [String]
}

"""The where unique filter which can match at-most 1 object."""
input ProfileWhereUniqueInput {
id: ID
userEmail: String
}

"""Order by input for Profile's scalar fields"""
enum ProfileOrderByInput {
id_ASC
id_DSC
bio_ASC
bio_DSC
userEmail_ASC
userEmail_DSC
}

"""Profile"""
type Profile implements Node {
id: ID! @map(name: "profileId") @unique
bio: String
user: User!
userEmail: String! @unique
}

type ProfileEdge {
node: Profile!
cursor: String!
}

type ProfileConnection {
pageInfo: PageInfo!
edges: [ProfileEdge!]!
aggregate: Aggregate!
}

"""The where filter which can match zero or more objects"""
input PostWhereInput {
"""Logical AND on all given filters."""
AND: [PostWhereInput!]
"""Logical OR on all given filters."""
OR: [PostWhereInput!]
"""Logical NOT on all given filters combined by AND."""
NOT: [PostWhereInput!]
"""equals"""
id: String
"""not equals"""
id_not: String
"""contains substring"""
id_contains: String
"""doesn't contain substring"""
id_not_contains: String
id_starts_with: String
id_not_starts_with: String
id_ends_with: String
id_not_ends_with: String
"""less than"""
id_lt: String
"""less than or equals"""
id_lte: String
"""greater than"""
id_gt: String
"""greater than or equals"""
id_gte: String
"""in list"""
id_in: [String]
"""not in list"""
id_not_in: [String]
"""equals"""
createdAt: DateTime
"""not equals"""
createdAt_not: DateTime
"""less than"""
createdAt_lt: DateTime
"""less than or equals"""
createdAt_lte: DateTime
"""greater than"""
createdAt_gt: DateTime
"""greater than or equals"""
createdAt_gte: DateTime
"""in list"""
createdAt_in: [DateTime]
"""not in list"""
createdAt_not_in: [DateTime]
"""equals"""
updatedAt: DateTime
"""not equals"""
updatedAt_not: DateTime
"""less than"""
updatedAt_lt: DateTime
"""less than or equals"""
updatedAt_lte: DateTime
"""greater than"""
updatedAt_gt: DateTime
"""greater than or equals"""
updatedAt_gte: DateTime
"""in list"""
updatedAt_in: [DateTime]
"""not in list"""
updatedAt_not_in: [DateTime]
"""equals"""
title: String
"""not equals"""
title_not: String
"""contains substring"""
title_contains: String
"""doesn't contain substring"""
title_not_contains: String
title_starts_with: String
title_not_starts_with: String
title_ends_with: String
title_not_ends_with: String
"""less than"""
title_lt: String
"""less than or equals"""
title_lte: String
"""greater than"""
title_gt: String
"""greater than or equals"""
title_gte: String
"""in list"""
title_in: [String]
"""not in list"""
title_not_in: [String]
"""equals"""
published: Boolean
"""not equals"""
published_not: Boolean
"""condition must be true for related node"""
author: UserWhereInput
"""is the relation field null"""
author_is_null: Boolean
"""equals"""
authorId: String
"""not equals"""
authorId_not: String
"""contains substring"""
authorId_contains: String
"""doesn't contain substring"""
authorId_not_contains: String
authorId_starts_with: String
authorId_not_starts_with: String
authorId_ends_with: String
authorId_not_ends_with: String
"""less than"""
authorId_lt: String
"""less than or equals"""
authorId_lte: String
"""greater than"""
authorId_gt: String
"""greater than or equals"""
authorId_gte: String
"""in list"""
authorId_in: [String]
"""not in list"""
authorId_not_in: [String]
"""equals"""
categoryIds: String
"""not equals"""
categoryIds_not: String
"""contains substring"""
categoryIds_contains: String
"""doesn't contain substring"""
categoryIds_not_contains: String
categoryIds_starts_with: String
categoryIds_not_starts_with: String
categoryIds_ends_with: String
categoryIds_not_ends_with: String
"""less than"""
categoryIds_lt: String
"""less than or equals"""
categoryIds_lte: String
"""greater than"""
categoryIds_gt: String
"""greater than or equals"""
categoryIds_gte: String
"""in list"""
categoryIds_in: [String]
"""not in list"""
categoryIds_not_in: [String]
"""condition must be true for all nodes"""
category_every: CategoryWhereInput
"""condition must be true for at least 1 node"""
category_some: CategoryWhereInput
"""condition must be false for all nodes"""
category_none: CategoryWhereInput
"""is the relation field empty"""
category_is_empty: Boolean
}

"""The where unique filter which can match at-most 1 object."""
input PostWhereUniqueInput {
id: ID
}

"""Order by input for Post's scalar fields"""
enum PostOrderByInput {
id_ASC
id_DSC
createdAt_ASC
createdAt_DSC
updatedAt_ASC
updatedAt_DSC
title_ASC
title_DSC
published_ASC
published_DSC
authorId_ASC
authorId_DSC
}

"""Post"""
type Post implements Node {
id: ID! @map(name: "postId") @unique
createdAt: DateTime!
updatedAt: DateTime!
title: String!
published: Boolean!
author: User!
authorId: String!
categoryIds: [String!]!
category(
where: CategoryWhereInput
orderBy: CategoryOrderByInput
skip: Int
after: ID
before: ID
first: Int
last: Int
): [Category!]!
categoryConnection(
where: CategoryWhereInput
orderBy: CategoryOrderByInput
skip: Int
after: ID
before: ID
first: Int
last: Int
): [CategoryConnection!]!
}

type PostEdge {
node: Post!
cursor: String!
}

type PostConnection {
pageInfo: PageInfo!
edges: [PostEdge!]!
aggregate: Aggregate!
}

"""The where filter which can match zero or more objects"""
input CategoryWhereInput {
"""Logical AND on all given filters."""
AND: [CategoryWhereInput!]
"""Logical OR on all given filters."""
OR: [CategoryWhereInput!]
"""Logical NOT on all given filters combined by AND."""
NOT: [CategoryWhereInput!]
"""equals"""
id: String
"""not equals"""
id_not: String
"""contains substring"""
id_contains: String
"""doesn't contain substring"""
id_not_contains: String
id_starts_with: String
id_not_starts_with: String
id_ends_with: String
id_not_ends_with: String
"""less than"""
id_lt: String
"""less than or equals"""
id_lte: String
"""greater than"""
id_gt: String
"""greater than or equals"""
id_gte: String
"""in list"""
id_in: [String]
"""not in list"""
id_not_in: [String]
"""equals"""
name: String
"""not equals"""
name_not: String
"""contains substring"""
name_contains: String
"""doesn't contain substring"""
name_not_contains: String
name_starts_with: String
name_not_starts_with: String
name_ends_with: String
name_not_ends_with: String
"""less than"""
name_lt: String
"""less than or equals"""
name_lte: String
"""greater than"""
name_gt: String
"""greater than or equals"""
name_gte: String
"""in list"""
name_in: [String]
"""not in list"""
name_not_in: [String]
"""equals"""
postIDs: String
"""not equals"""
postIDs_not: String
"""contains substring"""
postIDs_contains: String
"""doesn't contain substring"""
postIDs_not_contains: String
postIDs_starts_with: String
postIDs_not_starts_with: String
postIDs_ends_with: String
postIDs_not_ends_with: String
"""less than"""
postIDs_lt: String
"""less than or equals"""
postIDs_lte: String
"""greater than"""
postIDs_gt: String
"""greater than or equals"""
postIDs_gte: String
"""in list"""
postIDs_in: [String]
"""not in list"""
postIDs_not_in: [String]
"""condition must be true for all nodes"""
posts_every: PostWhereInput
"""condition must be true for at least 1 node"""
posts_some: PostWhereInput
"""condition must be false for all nodes"""
posts_none: PostWhereInput
"""is the relation field empty"""
posts_is_empty: Boolean
}

"""The where unique filter which can match at-most 1 object."""
input CategoryWhereUniqueInput {
id: ID
}

"""Order by input for Category's scalar fields"""
enum CategoryOrderByInput {
id_ASC
id_DSC
name_ASC
name_DSC
}

"""Category"""
type Category implements Node {
id: ID! @map(name: "categoryId") @unique
name: String!
postIDs: [String!]!
posts(
where: PostWhereInput
orderBy: PostOrderByInput
skip: Int
after: ID
before: ID
first: Int
last: Int
): [Post!]!
postsConnection(
where: PostWhereInput
orderBy: PostOrderByInput
skip: Int
after: ID
before: ID
first: Int
last: Int
): [PostConnection!]!
}

type CategoryEdge {
node: Category!
cursor: String!
}

type CategoryConnection {
pageInfo: PageInfo!
edges: [CategoryEdge!]!
aggregate: Aggregate!
}

type Query {
node(
id: ID!
): Node
user(
where: UserWhereUniqueInput!
): User
users(
where: UserWhereInput
orderBy: UserOrderByInput
skip: Int
after: ID
before: ID
first: Int
last: Int
): [User!]!
usersConnection(
where: UserWhereInput
orderBy: UserOrderByInput
skip: Int
after: ID
before: ID
first: Int
last: Int
): UserConnection!
profile(
where: ProfileWhereUniqueInput!
): Profile
profiles(
where: ProfileWhereInput
orderBy: ProfileOrderByInput
skip: Int
after: ID
before: ID
first: Int
last: Int
): [Profile!]!
profilesConnection(
where: ProfileWhereInput
orderBy: ProfileOrderByInput
skip: Int
after: ID
before: ID
first: Int
last: Int
): ProfileConnection!
post(
where: PostWhereUniqueInput!
): Post
posts(
where: PostWhereInput
orderBy: PostOrderByInput
skip: Int
after: ID
before: ID
first: Int
last: Int
): [Post!]!
postsConnection(
where: PostWhereInput
orderBy: PostOrderByInput
skip: Int
after: ID
before: ID
first: Int
last: Int
): PostConnection!
category(
where: CategoryWhereUniqueInput!
): Category
categories(
where: CategoryWhereInput
orderBy: CategoryOrderByInput
skip: Int
after: ID
before: ID
first: Int
last: Int
): [Category!]!
categoriesConnection(
where: CategoryWhereInput
orderBy: CategoryOrderByInput
skip: Int
after: ID
before: ID
first: Int
last: Int
): CategoryConnection!
}

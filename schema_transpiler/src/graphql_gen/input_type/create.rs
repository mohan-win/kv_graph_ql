use super::*;

/// Code-gen for *create input types* for the given model.
/// It generates,
/// * {ModelName}CreateInput,
/// * {ModelName}CreateOneInlineInput,
/// * {ModelName}CreateManyInlineInput.
pub(in crate::graphql_gen) fn create_input_types_def<'src>(
    model: &sdml_ast::ModelDecl<'src>,
) -> GraphQLGenResult<Vec<TypeDefinition>> {
    Ok(vec![
        create_input_def(model)?,
        create_one_inline_input_def(model)?,
        create_many_inline_input_def(model)?,
    ])
}

/// Input type used to create a new object.
/// Ex. UserCreateInput creates a new user.
fn create_input_def<'src>(
    model: &sdml_ast::ModelDecl<'src>,
) -> GraphQLGenResult<TypeDefinition> {
    // Note: Filter out relation_scalar fields & auto generated ids. But include unique & id (which is not auto-gen.) fields.
    // Why?
    // 1. Relation scalar fields will be populated with the content of *CreateInlineInput fields.
    // 2. Autogenerated ids will be auto-generated by DB engine module, not inputted by the user.
    // 3. CreateInput type can include input-arg for unique fields.
    let model_fields = model.get_fields();
    let mut non_relation_fields = Vec::new();
    model_fields.id.iter().for_each(|(id_field, is_auto_gen)| {
        if !is_auto_gen {
            non_relation_fields.push(*id_field);
        }
    });
    non_relation_fields.extend(&model_fields.unique);
    non_relation_fields
        .extend(model_fields.get_rest(sdml_ast::ModelIndexedFieldsFilter::All));

    let mut input_field_defs = non_relation_fields
        .into_iter()
        .map(non_relation_field_input_def)
        .collect::<GraphQLGenResult<Vec<InputValueDefinition>>>()?;
    let relation_input_field_defs = model_fields
        .relation
        .into_iter()
        .map(relation_field_input_def)
        .collect::<GraphQLGenResult<Vec<InputValueDefinition>>>()?;
    input_field_defs.extend(relation_input_field_defs);

    let model_name = model
        .name
        .try_get_ident_name()
        .map_err(ErrorGraphQLGen::new_sdml_error)?;
    Ok(TypeDefinition {
        extend: false,
        description: None,
        name: open_crud_name::types::CreateInput::Create.name(model_name),
        directives: vec![],
        kind: TypeKind::InputObject(InputObjectType {
            fields: input_field_defs,
        }),
    })
}

/// Code-gen input arg for the non-relation field.
fn non_relation_field_input_def<'src>(
    field: &sdml_ast::FieldDecl<'src>,
) -> GraphQLGenResult<InputValueDefinition> {
    let ty_str = match &*field.field_type.r#type() {
        sdml_ast::Type::Unknown(..) | sdml_ast::Type::Relation(..) => {
            Err(ErrorGraphQLGen::SDMLError {
                error: "Only non-relation field is allowed here.".to_string(),
                pos: field.name.span(),
            })
        }
        sdml_ast::Type::Primitive { r#type, .. } => {
            Ok(Type::map_sdml_type_to_graphql_ty_name(r#type))
        }
        sdml_ast::Type::Enum { enum_ty_name } => Ok(enum_ty_name
            .try_get_ident_name()
            .map_err(ErrorGraphQLGen::new_sdml_error)?
            .to_string()),
    }?;
    let mut description = None;
    let default_attribute = field.default_attribute();
    let type_mod: TypeMod = if default_attribute.is_some() {
        description = Some(format!(
            "Default value '{}' will be assigned if no value is passed to this input arg.",
            default_attribute.unwrap().arg.as_ref().unwrap()
        ));
        // If the field has default attribute, make the type as optional.
        // Note: The default attribute is allowed only on a scalar field.
        // Otherwise SDML parser would fail. Hence we need not bother
        // about @default(..) being present on an array model field.
        sdml_ast::FieldTypeMod::Optional
    } else {
        field.field_type.type_mod
    }.into();

    Ok(InputValueDefinition {
        description,
        name: field
            .name
            .try_get_graphql_name()
            .map_err(ErrorGraphQLGen::new_sdml_error)?,
        ty: Type::new(&ty_str, type_mod),
        default_value: None, // Note: The default value is set to None. The appropriate default
        directives: vec![],
    })
}

/// Code-gen input arg for the relation field.
fn relation_field_input_def<'src>(
    field: &sdml_ast::FieldDecl<'src>,
) -> GraphQLGenResult<InputValueDefinition> {
    if let sdml_ast::Type::Relation(edge) = &*field.field_type.r#type() {
        let field_name = field
            .name
            .try_get_graphql_name()
            .map_err(ErrorGraphQLGen::new_sdml_error)?;
        let referenced_model_name = edge
            .referenced_model_name()
            .try_get_ident_name()
            .map_err(ErrorGraphQLGen::new_sdml_error)?;
        let field_ty = if field.field_type.is_array() {
            open_crud_name::types::CreateInput::CreateManyInline
                .ty(referenced_model_name, TypeMod::NonOptional)
        } else if field.field_type.is_optional() {
            open_crud_name::types::CreateInput::CreateOneInline
                .ty(referenced_model_name, TypeMod::Optional)
        } else {
            open_crud_name::types::CreateInput::CreateOneInline
                .ty(referenced_model_name, TypeMod::NonOptional)
        };
        Ok(InputValueDefinition {
            description: None,
            name: field_name,
            ty: field_ty,
            default_value: None,
            directives: vec![],
        })
    } else {
        Err(ErrorGraphQLGen::SDMLError {
            error: "Only relation field is expected!".to_string(),
            pos: field.name.span(),
        })
    }
}

/// Input type used to create one object in one side of the relation
/// in a nested create.
/// Ex. ProfileCreateOneInlineInput will be used inside UserCreateInput
/// to create user profile inline when creating a new user.
fn create_one_inline_input_def<'src>(
    model: &sdml_ast::ModelDecl<'src>,
) -> GraphQLGenResult<TypeDefinition> {
    let model_name = model
        .name
        .try_get_ident_name()
        .map_err(ErrorGraphQLGen::new_sdml_error)?;
    let create_field = InputValueDefinition {
        description: None,
        name: open_crud_name::fields::CreateInputArg::Create.common_name(),
        ty: open_crud_name::types::CreateInput::Create.ty(model_name, TypeMod::Optional),
        default_value: None,
        directives: vec![],
    };
    let connect_field = InputValueDefinition {
        description: None,
        name: open_crud_name::fields::CreateInputArg::Connect.common_name(),
        ty: open_crud_name::types::FilterInput::WhereUnique
            .ty(model_name, TypeMod::Optional),
        default_value: None,
        directives: vec![],
    };

    Ok(TypeDefinition {
        extend: false,
        description: None,
        name: open_crud_name::types::CreateInput::CreateOneInline.name(model_name),
        directives: vec![],
        kind: TypeKind::InputObject(InputObjectType {
            fields: vec![create_field, connect_field],
        }),
    })
}

/// Input type used to create the many objects in a relation
/// in a nested create.
/// Ex. PostCreateManyInlineInput will be used inside UserCreateInput
/// to create posts inline when creating a new user.
fn create_many_inline_input_def<'src>(
    model: &sdml_ast::ModelDecl<'src>,
) -> GraphQLGenResult<TypeDefinition> {
    let model_name = model
        .name
        .try_get_ident_name()
        .map_err(ErrorGraphQLGen::new_sdml_error)?;
    let create_field = InputValueDefinition {
        description: None,
        name: open_crud_name::fields::CreateInputArg::Create.common_name(),
        ty: open_crud_name::types::CreateInput::Create
            .ty(model_name, TypeMod::ArrayOptional),
        default_value: None,
        directives: vec![],
    };
    let connect_field = InputValueDefinition {
        description: None,
        name: open_crud_name::fields::CreateInputArg::Connect.common_name(),
        ty: open_crud_name::types::FilterInput::WhereUnique
            .ty(model_name, TypeMod::ArrayOptional),
        default_value: None,
        directives: vec![],
    };

    Ok(TypeDefinition {
        extend: false,
        description: None,
        name: open_crud_name::types::CreateInput::CreateManyInline.name(model_name),
        directives: vec![],
        kind: TypeKind::InputObject(InputObjectType {
            fields: vec![create_field, connect_field],
        }),
    })
}

#[cfg(test)]
mod tests {
    use crate::graphql_gen::TypeDefinition;

    use super::create_input_types_def;

    use chumsky::prelude::*;
    use sdml_parser::parser;
    use std::fs;

    #[test]
    fn test_user_create_input_types_def() {
        let mut expected_graphql_str = fs::read_to_string(concat!(
            env!("CARGO_MANIFEST_DIR"),
            "/test_data/input_type/test_user_create_input_types_def.graphql"
        ))
        .unwrap();
        expected_graphql_str.retain(|c| !c.is_whitespace());

        let sdml_str = fs::read_to_string(concat!(
            env!("CARGO_MANIFEST_DIR"),
            "/test_data/input_type/test_user_create_input_types_def.sdml"
        ))
        .unwrap();
        let sdml_declarations = parser::delcarations()
            .parse(&sdml_str)
            .into_output()
            .expect("It should be a valid SDML.");
        let data_model = parser::semantic_analysis(sdml_declarations)
            .expect("A valid SDML file shouldn't fail in parsing.");
        let user_model_sdml_ast = data_model
            .models()
            .get("User")
            .expect("User model should exist in the SDML.");
        let create_user_input_type_graphql_ast =
            create_input_types_def(user_model_sdml_ast)
                .expect("It should return all 'create user input types'.");

        let mut create_user_input_type_graphql_str = create_user_input_type_graphql_ast
            .into_iter()
            .fold("".to_string(), |acc, input_ty| {
                format!("{}{}", acc, input_ty.to_string())
            });

        create_user_input_type_graphql_str.retain(|c| !c.is_whitespace());
        assert_eq!(expected_graphql_str, create_user_input_type_graphql_str)
    }

    #[test]
    fn test_create_input_types_def() {
        let mut expected_graphql_str = fs::read_to_string(concat!(
            env!("CARGO_MANIFEST_DIR"),
            "/test_data/input_type/test_create_input_types_def.graphql"
        ))
        .unwrap();
        expected_graphql_str.retain(|c| !c.is_whitespace());

        let sdml_str = fs::read_to_string(concat!(
            env!("CARGO_MANIFEST_DIR"),
            "/test_data/input_type/test_create_input_types_def.sdml"
        ))
        .unwrap();
        let sdml_declarations = parser::delcarations()
            .parse(&sdml_str)
            .into_output()
            .expect("It should be a valid SDML.");
        let data_model = parser::semantic_analysis(sdml_declarations)
            .expect("A valid SDML file shouldn't fail in parsing.");
        let create_input_types_def_graphql_ast = data_model
            .models_sorted()
            .iter()
            .flat_map(|model| create_input_types_def(model).expect("create_input_types_def should return with all input types for the model."))
            .collect::<Vec<TypeDefinition>>();

        let mut create_input_types_def_graphql_str = create_input_types_def_graphql_ast
            .into_iter()
            .fold("".to_string(), |acc, input_ty| {
                format!("{}{}", acc, input_ty.to_string())
            });
        create_input_types_def_graphql_str.retain(|c| !c.is_whitespace());
        assert_eq!(expected_graphql_str, create_input_types_def_graphql_str)
    }
}
